<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Serechi - Your Trusted Healthcare Companion. Connect with professional healthcare providers for home nursing, elderly care, physiotherapy, and more.">
  
  <!-- Cache Busting: Force browsers to always load latest version -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Serechi">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="logo.png"/>

  <title>Serechi</title>
  <link rel="manifest" href="manifest.json">
  
  <!-- CRITICAL: Automatic version check with proper cache clearing -->
  <script>
    (function() {
      // STEP 1: Unregister all service workers FIRST to prevent re-caching
      var swPromise = Promise.resolve();
      if ('serviceWorker' in navigator) {
        swPromise = navigator.serviceWorker.getRegistrations().then(function(registrations) {
          console.log('üîß Unregistering ' + registrations.length + ' service workers...');
          return Promise.all(registrations.map(function(r) { return r.unregister(); }));
        });
      }
      
      // STEP 2: Check version after service workers are unregistered
      swPromise.then(function() {
        var currentVersion = localStorage.getItem('app_version');
        var isReloading = sessionStorage.getItem('version_reload');
        var versionCheckUrl = 'version.json?cacheBust=' + Date.now();
        
        // Prevent infinite reload loop - only reload once per session
        if (isReloading === 'true') {
          console.log('‚úÖ Reload completed, clearing reload flag');
          sessionStorage.removeItem('version_reload');
          return;
        }
        
        fetch(versionCheckUrl, {
          cache: 'no-store',
          headers: { 
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          }
        })
        .then(function(response) { 
          if (!response.ok) throw new Error('Version fetch failed');
          return response.json(); 
        })
        .then(function(data) {
          var serverVersion = data.version + '+' + data.buildNumber;
          console.log('üì¶ Server version: ' + serverVersion + ' | Local: ' + (currentVersion || 'none'));
          
          // Use VERSION+BUILD for cache busting
          // Web versions can increment independently from Play Store
          if (currentVersion && currentVersion !== serverVersion) {
            console.log('üîÑ NEW VERSION DETECTED - Clearing caches and reloading...');
            
            // Mark that we're about to reload (prevents infinite loop)
            sessionStorage.setItem('version_reload', 'true');
            
            // Clear all caches, then reload
            if ('caches' in window) {
              caches.keys().then(function(names) {
                return Promise.all(names.map(function(n) { return caches.delete(n); }));
              }).then(function() {
                console.log('‚úÖ Caches cleared, updating version and reloading...');
                localStorage.setItem('app_version', serverVersion);
                // Hard reload bypassing cache without polluting URL
                window.location.reload(true);
              });
            } else {
              localStorage.setItem('app_version', serverVersion);
              window.location.reload(true);
            }
          } else {
            // Same version or first load
            localStorage.setItem('app_version', serverVersion);
            console.log('‚úÖ Version up to date: ' + serverVersion);
          }
        })
        .catch(function(err) {
          console.warn('‚ö†Ô∏è Version check failed:', err);
          // Continue loading even if version check fails
        });
      });
    })();
  </script>
  
  <!-- Auto-redirect non-www to www for consistent localStorage -->
  <script>
    if (window.location.hostname === 'srcarehive.com') {
      window.location.replace('https://www.srcarehive.com' + window.location.pathname + window.location.search + window.location.hash);
    }
  </script>
</head>
<body>
  <!-- CRITICAL: Cache busting with timestamp for flutter_bootstrap.js -->
  <!-- The timestamp parameter forces browsers to fetch latest bootstrap -->
  <script>
    var cacheBustVersion = Date.now();
    var script = document.createElement('script');
    script.src = 'flutter_bootstrap.js?v=' + cacheBustVersion;
    script.async = true;
    document.body.appendChild(script);
  </script>
</body>
    <!-- Razorpay Checkout for Flutter Web -->
    <script src="https://checkout.razorpay.com/v1/checkout.js"></script>
    <script>
      // Enhanced Razorpay bridge for Flutter Web with proper success handling
      window.care12OpenRazorpay = function (options) {
        try {
          console.log('[Razorpay Bridge] Initializing with options:', options);
          
          // CRITICAL: Add handler callback - this is called when user completes payment successfully
          // This is the PRIMARY way Razorpay communicates success
          options.handler = function(response) {
            console.log('[Razorpay Bridge] ‚úÖ Payment SUCCESS - handler called with response:', response);
            
            // Dispatch success event immediately when payment completes
            var successEvent = new CustomEvent('rzp_success', { 
              detail: {
                razorpay_payment_id: response.razorpay_payment_id,
                razorpay_order_id: response.razorpay_order_id,
                razorpay_signature: response.razorpay_signature
              }
            });
            window.dispatchEvent(successEvent);
            console.log('[Razorpay Bridge] ‚úÖ Success event dispatched to Flutter');
          };
          
          // Add modal ondismiss to handle user closing the payment screen
          if (!options.modal) {
            options.modal = {};
          }
          options.modal.ondismiss = function() {
            console.log('[Razorpay Bridge] ‚ö†Ô∏è Payment modal closed by user');
            // Only send failure if payment wasn't already successful
            setTimeout(function() {
              window.dispatchEvent(new CustomEvent('rzp_failed', { 
                detail: { 
                  error: { 
                    code: 'payment_cancelled', 
                    description: 'Payment cancelled by user' 
                  } 
                } 
              }));
            }, 100);
          };
          
          // Create Razorpay instance
          var rzp = new Razorpay(options);
          
          // Additional event listeners as backup
          rzp.on('payment.success', function (resp) {
            console.log('[Razorpay Bridge] üéâ payment.success event:', resp);
            window.dispatchEvent(new CustomEvent('rzp_success', { detail: resp }));
          });
          
          rzp.on('payment.failed', function (resp) {
            console.log('[Razorpay Bridge] ‚ùå payment.failed event:', resp);
            window.dispatchEvent(new CustomEvent('rzp_failed', { detail: resp }));
          });
          
          rzp.on('payment.error', function (resp) {
            console.log('[Razorpay Bridge] ‚ùå payment.error event:', resp);
            window.dispatchEvent(new CustomEvent('rzp_failed', { detail: resp }));
          });
          
          // Open Razorpay checkout
          console.log('[Razorpay Bridge] Opening Razorpay checkout modal...');
          rzp.open();
          
        } catch (e) {
          console.error('[Razorpay Bridge] ‚ùå Exception:', e);
          window.dispatchEvent(new CustomEvent('rzp_failed', { 
            detail: { 
              error: { 
                code: 'exception', 
                description: String(e) 
              } 
            } 
          }));
        }
      };
      
      console.log('[Razorpay Bridge] Bridge function registered successfully');
    </script>
